import { useState, useMemo, useRef } from "react";

const TRUCK = { name: "–§—É—Ä–∞", length: 13600, width: 2440, height: 2580, maxWeight: 22000, floorSpacer: 0, layerSpacer: 0 };
const WAGON = { name: "–ü–æ–ª—É–≤–∞–≥–æ–Ω", length: 12680, width: 2830, height: 2170, maxWeight: 63000, floorSpacer: 0, layerSpacer: 0 };

const MATERIALS = [
  { id: "steel", name: "–°—Ç–∞–ª—å", density: 7850 },
  { id: "stainless", name: "–ù–µ—Ä–∂–∞–≤–µ–π–∫–∞", density: 7900 },
  { id: "aluminum", name: "–ê–ª—é–º–∏–Ω–∏–π", density: 2700 },
  { id: "copper", name: "–ú–µ–¥—å", density: 8900 },
  { id: "brass", name: "–õ–∞—Ç—É–Ω—å", density: 8500 },
  { id: "bronze", name: "–ë—Ä–æ–Ω–∑–∞", density: 8800 },
  { id: "titanium", name: "–¢–∏—Ç–∞–Ω", density: 4505 },
  { id: "castiron", name: "–ß—É–≥—É–Ω", density: 7200 },
  { id: "zinc", name: "–¶–∏–Ω–∫", density: 7130 },
  { id: "lead", name: "–°–≤–∏–Ω–µ—Ü", density: 11340 },
];

const WAGON_NORMS = [
  { d: 114, loose: 361, packStd: 325, packHigh: 361 },
  { d: 146, loose: 211, packStd: 180, packHigh: 211 },
  { d: 159, loose: 216, packStd: 180, packHigh: 200 },
  { d: 168, loose: 190, packStd: 110, packHigh: 140 },
  { d: 219, loose: 117, packStd: 90,  packHigh: 110 },
  { d: 273, loose: 80,  packStd: 64,  packHigh: 72 },
  { d: 325, loose: 56,  packStd: 48,  packHigh: 64 },
  { d: 377, loose: 42,  packStd: 36,  packHigh: 42 },
  { d: 426, loose: 30,  packStd: 30,  packHigh: 36 },
  { d: 530, loose: null, packStd: 20, packHigh: 24 },
  { d: 630, loose: null, packStd: null, packHigh: null, capStd: 19 },
];

const WAGON_MASS_NORMS_12M = {
  114: { 3.0: 35476, 3.5: 41201, 4.0: 46873, 4.5: 52493, 5.0: 58059, 5.5: 63572, 6.0: 69000 },
  146: { 4.0: 35410, 4.5: 39567, 5.0: 43810, 5.5: 48025, 6.0: 52196, 6.5: 56352, 7.0: 60480, 8.0: 69000 },
  159: { 4.0: 39550, 4.5: 44466, 5.0: 49159, 5.5: 54074, 6.0: 58767, 8.0: 69000 },
  168: { 5.0: 69000, 6.0: 69000, 7.0: 69000, 8.0: 69000 },
  219: { 3.0: 22436, 3.5: 26114, 4.0: 29779, 4.5: 33415, 5.0: 37052, 5.5: 40716, 6.0: 40659, 7.0: 51386, 8.0: 58448, 9.0: 65440, 10.0: 69000 },
  273: { 3.0: 19180, 3.5: 22326, 4.0: 25478, 4.5: 28608, 5.0: 31728, 6.0: 37929, 7.0: 44083, 8.0: 50189, 9.0: 56256, 10.0: 62266, 11.0: 69000, 12.0: 69000 },
  325: { 3.5: 18648, 4.0: 21282, 4.5: 23903, 5.0: 26517, 6.0: 31718, 7.0: 36893, 8.0: 42027, 9.0: 47134, 10.0: 52201, 11.0: 57241, 12.0: 62247, 14.0: 69000 },
  377: { 4.0: 18543, 4.5: 20836, 5.0: 23119, 6.0: 27669, 7.0: 32190, 8.0: 36691, 9.0: 41166, 10.0: 45617, 11.0: 50042, 12.0: 54442, 14.0: 63167, 16.0: 69000 },
  426: { 4.5: 16840, 5.0: 18688, 6.0: 22374, 7.0: 26039, 8.0: 29690, 9.0: 33318, 10.0: 36932, 11.0: 40529, 12.0: 44107, 14.0: 51209, 16.0: 58240, 17.5: 63468, 19.0: 69000 },
  530: { 6.0: 18600, 7.0: 21662, 8.0: 24724, 9.0: 27745, 10.0: 30786, 11.0: 33786, 12.0: 36786, 13.0: 39780, 14.0: 42766, 16.0: 48683, 17.0: 51620, 17.5: 53090, 19.0: 57455, 20.0: 60372 },
  630: { 6.0: 21050, 7.0: 24521, 8.0: 27980, 9.0: 31425, 10.0: 34861, 11.0: 38285, 12.0: 41705, 13.0: 45101, 14.0: 48491, 16.0: 55237, 17.0: 58596, 17.5: 60269, 18.0: 61941, 19.0: 65277, 20.0: 69000 },
};

function findNearestNorm(diameter) {
  let best = null, bestDiff = Infinity;
  for (const n of WAGON_NORMS) {
    const diff = Math.abs(n.d - diameter);
    const tolerance = diameter < 300 ? 5 : 10;
    if (diff < bestDiff && diff <= tolerance) { best = n; bestDiff = diff; }
  }
  return best;
}

function getWagonPipesFromNorms(diameter) {
  const norm = findNearestNorm(diameter);
  if (!norm) return null;
  const pipes = norm.loose || norm.packStd || norm.capStd || null;
  return { pipes, source: "–Ω–æ—Ä–º—ã", normDiameter: norm.d, packStd: norm.packStd, packHigh: norm.packHigh, loose: norm.loose, capStd: norm.capStd };
}

function getWagonMaxMass(diameter, thickness) {
  let bestD = null, bestDiff = Infinity;
  const tolerance = diameter < 300 ? 5 : 10;
  for (const d of Object.keys(WAGON_MASS_NORMS_12M)) {
    const diff = Math.abs(+d - diameter);
    if (diff < bestDiff && diff <= tolerance) { bestD = d; bestDiff = diff; }
  }
  if (!bestD) return null;
  const thicknesses = WAGON_MASS_NORMS_12M[bestD];
  const keys = Object.keys(thicknesses).map(Number).sort((a, b) => a - b);
  if (thickness <= keys[0]) return thicknesses[keys[0]];
  if (thickness >= keys[keys.length - 1]) return thicknesses[keys[keys.length - 1]];
  for (let i = 0; i < keys.length - 1; i++) {
    if (thickness >= keys[i] && thickness <= keys[i + 1]) {
      const t = (thickness - keys[i]) / (keys[i + 1] - keys[i]);
      return Math.round(thicknesses[keys[i]] * (1 - t) + thicknesses[keys[i + 1]] * t);
    }
  }
  return null;
}

function calcWeightPerMeter(D, t, density) {
  if (D <= 0 || t <= 0 || D <= 2 * t) return 0;
  return Math.round(Math.PI * t * (D - t) / 1e6 * density * 100) / 100;
}

function generateId() { return Date.now() + Math.random(); }
function calcPipeWeight(row) { return row.weightPerMeter * (row.length / 1000) * row.count; }

class TruckSimulator {
  constructor(vehicle) {
    this.vehicle = vehicle;
    this.layers = [];
    this.totalWeight = 0;
    this.usedHeight = 0;
  }

  tryAddPipes(pipeData, maxCount) {
    const { diameter, weightPerPipe, length } = pipeData;
    let added = 0;
    
    for (let i = 0; i < maxCount; i++) {
      const newWeight = this.totalWeight + weightPerPipe;
      if (newWeight > this.vehicle.maxWeight) break;
      
      let placed = false;
      
      // –°—Ç—Ä–∞—Ç–µ–≥–∏—è 1: –ü—ã—Ç–∞–µ–º—Å—è –¥–æ–±–∞–≤–∏—Ç—å –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Å–ª–æ–π —Ç–æ–π –∂–µ –≤—ã—Å–æ—Ç—ã
      for (const layer of this.layers) {
        if (layer.height === diameter && layer.occupiedWidth + diameter <= this.vehicle.width) {
          this.placeInLayer(layer, diameter, length);
          placed = true;
          break;
        }
      }
      
      // –°—Ç—Ä–∞—Ç–µ–≥–∏—è 2: –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π —Å–ª–æ–π
      if (!placed) {
        const newLayerHeight = this.usedHeight + diameter;
        if (newLayerHeight <= this.vehicle.height) {
          const newLayer = {
            y: this.usedHeight,
            height: diameter,
            width: this.vehicle.width,
            pipes: [{ diameter, length, x: 0, count: 1 }],
            occupiedWidth: diameter
          };
          this.layers.push(newLayer);
          this.usedHeight = newLayerHeight;
          placed = true;
        }
      }
      
      if (placed) {
        this.totalWeight = newWeight;
        added++;
      } else {
        break;
      }
    }
    
    return added;
  }

  placeInLayer(layer, diameter, length) {
    // –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –≥—Ä—É–ø–ø—É —Ç—Ä—É–± —Ç–æ–≥–æ –∂–µ –¥–∏–∞–º–µ—Ç—Ä–∞ –∏ –¥–ª–∏–Ω—ã –≤ –∫–æ–Ω—Ü–µ —Å–ª–æ—è
    const existing = layer.pipes.find(p => 
      p.diameter === diameter && 
      p.length === length &&
      p.x + diameter * p.count === layer.occupiedWidth
    );
    
    if (existing) {
      existing.count++;
    } else {
      layer.pipes.push({ 
        diameter, 
        length, 
        x: layer.occupiedWidth, 
        count: 1 
      });
    }
    layer.occupiedWidth += diameter;
  }

  getLoadedPipes() {
    const result = {};
    for (const layer of this.layers) {
      for (const pipe of layer.pipes) {
        const key = `${pipe.diameter}x${pipe.length}`;
        if (!result[key]) result[key] = 0;
        result[key] += pipe.count;
      }
    }
    return result;
  }

  clone() {
    const clone = new TruckSimulator(this.vehicle);
    clone.layers = JSON.parse(JSON.stringify(this.layers));
    clone.totalWeight = this.totalWeight;
    clone.usedHeight = this.usedHeight;
    return clone;
  }
}

function optimizeLoading(positions, vehicle) {
  const sorted = [...positions].sort((a, b) => {
    const weightA = a.weightPerMeter * (a.length / 1000);
    const weightB = b.weightPerMeter * (b.length / 1000);
    return weightB - weightA;
  });

  const vehicles = [];
  const remaining = sorted.map(p => ({ ...p, remaining: p.count }));

  while (remaining.some(p => p.remaining > 0)) {
    const bestCombo = findBestCombination(remaining.filter(p => p.remaining > 0), vehicle);
    
    if (!bestCombo || bestCombo.composition.length === 0) {
      break;
    }
    
    const isMixed = bestCombo.composition.length > 1;
    vehicles.push({
      ...bestCombo,
      type: isMixed ? 'mixed' : 'single'
    });
    
    for (const item of bestCombo.composition) {
      const pos = remaining.find(p => 
        p.diameter === item.diameter && 
        p.length === item.length &&
        p.thickness === item.thickness
      );
      if (pos) pos.remaining -= item.count;
    }
  }

  return vehicles;
}

function findBestCombination(remainingItems, vehicle) {
  if (remainingItems.length === 0) return null;
  
  let bestSim = null;
  let bestScore = 0;

  if (remainingItems.length <= 8) {
    const allCombinations = generateCombinations(remainingItems);
    
    for (const combo of allCombinations) {
      const result = tryLoadCombination(combo, vehicle);
      const score = result.totalPipes + (result.weight / vehicle.maxWeight) * 100;
      
      if (score > bestScore) {
        bestScore = score;
        bestSim = result;
      }
    }
  } else {
    const strategies = [
      [...remainingItems].sort((a, b) => b.remaining - a.remaining),
      [...remainingItems].sort((a, b) => (b.weightPerMeter * b.remaining) - (a.weightPerMeter * a.remaining)),
      [...remainingItems].sort((a, b) => a.diameter - b.diameter),
      [...remainingItems].sort((a, b) => b.diameter - a.diameter),
    ];
    
    for (const strategy of strategies) {
      const result = tryLoadCombination(strategy, vehicle);
      const score = result.totalPipes + (result.weight / vehicle.maxWeight) * 100;
      
      if (score > bestScore) {
        bestScore = score;
        bestSim = result;
      }
    }
  }

  return bestSim && bestSim.composition.length > 0 ? { type: 'mixed', ...bestSim } : null;
}

function tryLoadCombination(positions, vehicle) {
  const sim = new TruckSimulator(vehicle);
  const composition = [];
  let totalPipes = 0;
  
  for (const pos of positions) {
    if (pos.remaining <= 0) continue;
    
    const weightPerPipe = pos.weightPerMeter * (pos.length / 1000);
    const added = sim.tryAddPipes({ 
      diameter: pos.diameter, 
      weightPerPipe,
      thickness: pos.thickness,
      length: pos.length
    }, pos.remaining);
    
    if (added > 0) {
      composition.push({ ...pos, count: added });
      totalPipes += added;
    }
  }
  
  return {
    simulator: sim,
    composition,
    weight: sim.totalWeight,
    totalPipes
  };
}

function generateCombinations(items) {
  const result = [];
  const n = items.length;
  
  for (let i = 1; i < (1 << n); i++) {
    const combo = [];
    for (let j = 0; j < n; j++) {
      if (i & (1 << j)) {
        combo.push(items[j]);
      }
    }
    
    const perms = generatePermutations(combo);
    result.push(...perms);
  }
  
  return result;
}

function generatePermutations(arr) {
  if (arr.length <= 1) return [arr];
  if (arr.length > 7) return [arr];
  
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];
    const perms = generatePermutations(rest);
    for (const perm of perms) {
      result.push([arr[i], ...perm]);
    }
  }
  return result;
}

function calcVehicles(rows, vehicle) {
  const isWagon = vehicle === WAGON;
  const totalWeight = rows.reduce((s, r) => s + calcPipeWeight(r), 0);
  
  const byGroup = {};
  rows.forEach(r => {
    const k = `${r.diameter}x${r.length}`;
    if (!byGroup[k]) byGroup[k] = { ...r, count: 0, totalWeight: 0 };
    byGroup[k].count += r.count;
    byGroup[k].totalWeight += calcPipeWeight(r);
  });
  
  const positions = Object.values(byGroup);
  const vehicles = optimizeLoading(positions, vehicle);
  
  return {
    totalWeight,
    totalVehicles: vehicles.length,
    vehicles,
    isWagon
  };
}

function formatKg(kg) { return kg >= 1000 ? (kg / 1000).toFixed(2) + " —Ç" : kg.toFixed(1) + " –∫–≥"; }
function formatMm(mm) { return mm >= 1000 ? (mm / 1000).toFixed(1) + " –º" : mm + " –º–º"; }

function StatCard({ label, value, sub, accent }) {
  return (
    <div className={`${accent ? 'bg-stone-900 border-amber-600' : 'bg-neutral-900 border-neutral-800'} border rounded-md p-4 min-w-[130px] flex-1`}>
      <div className="text-xs text-neutral-500 uppercase tracking-wide mb-1 font-mono">{label}</div>
      <div className={`text-2xl font-bold font-mono ${accent ? 'text-amber-500' : 'text-neutral-200'}`}>{value}</div>
      {sub && <div className="text-xs text-neutral-600 mt-0.5">{sub}</div>}
    </div>
  );
}

function NumInput({ value, onChange }) {
  const [editing, setEditing] = useState(false);
  const [text, setText] = useState("");

  const handleFocus = (e) => {
    setEditing(true);
    setText(String(value));
    setTimeout(() => e.target.select(), 0);
  };

  const handleBlur = () => {
    setEditing(false);
    const num = parseFloat(text);
    if (!isNaN(num)) onChange(num);
    else if (text === "") onChange(0);
  };

  return (
    <input
      type="text"
      inputMode="decimal"
      value={editing ? text : value}
      onFocus={handleFocus}
      onChange={e => setText(e.target.value)}
      onBlur={handleBlur}
      onKeyDown={e => { if (e.key === "Enter") e.target.blur(); }}
      className="bg-neutral-950 border border-neutral-700 rounded text-neutral-200 px-2.5 py-2 text-sm font-mono w-full outline-none"
    />
  );
}

function InputRow({ row, onChange, onRemove, index, density }) {
  const weight = calcPipeWeight(row);

  const handleDimChange = (field, value) => {
    const updated = { ...row, [field]: value };
    if (field === "diameter" || field === "thickness") {
      updated.weightPerMeter = calcWeightPerMeter(field === "diameter" ? value : row.diameter, field === "thickness" ? value : row.thickness, density);
    }
    
    if (field === "length" && row.totalMeters && value > 0) {
      updated.count = Math.ceil(row.totalMeters / (value / 1000));
    }
    
    onChange(updated);
  };

  const handleCountChange = (value) => {
    const updated = { ...row, count: Math.round(value) };
    if (row.length > 0) {
      updated.totalMeters = value * (row.length / 1000);
    }
    onChange(updated);
  };

  return (
    <tr className="border-b border-neutral-900">
      <td className="p-1 text-neutral-600 text-xs text-center w-7 font-mono align-middle">{index + 1}</td>
      <td className="p-1 align-middle"><div className="text-[10px] text-neutral-600 mb-0.5 font-mono">√ò –º–º</div><NumInput value={row.diameter} onChange={v => handleDimChange("diameter", v)} /></td>
      <td className="p-1 align-middle"><div className="text-[10px] text-neutral-600 mb-0.5 font-mono">–¢–æ–ª—â –º–º</div><NumInput value={row.thickness} onChange={v => handleDimChange("thickness", v)} /></td>
      <td className="p-1 align-middle">
        <div className="text-[10px] text-neutral-600 mb-0.5 font-mono">–î–ª–∏–Ω–∞ –º–º</div>
        <select 
          value={row.length} 
          onChange={e => handleDimChange("length", Number(e.target.value))}
          className="bg-neutral-950 border border-neutral-700 rounded text-neutral-200 px-2.5 py-2 text-sm font-mono w-full outline-none cursor-pointer"
        >
          <option value={6000}>6000</option>
          <option value={12000}>12000</option>
        </select>
      </td>
      <td className="p-1 align-middle"><div className="text-[10px] text-neutral-600 mb-0.5 font-mono">–ö–æ–ª-–≤–æ —à—Ç</div><NumInput value={row.count} onChange={handleCountChange} /></td>
      <td className="p-1 align-middle"><div className="text-[10px] text-neutral-600 mb-0.5 font-mono">–í–µ—Å –º/–ø –∫–≥</div><NumInput value={row.weightPerMeter} onChange={v => onChange({ ...row, weightPerMeter: v})} /></td>
      <td className="p-1 text-right min-w-[80px] align-middle"><div className="text-[10px] text-neutral-600 mb-0.5 font-mono">–í–µ—Å</div><div className="text-sm text-amber-600 font-semibold font-mono py-1">{formatKg(weight)}</div></td>
      <td className="p-1 w-8 align-middle"><button onClick={onRemove} className="bg-transparent border-0 text-neutral-600 text-lg cursor-pointer p-1 leading-none hover:text-neutral-400">√ó</button></td>
    </tr>
  );
}

function TruckVisualization({ simulator, vehicle }) {
  const padding = 20;
  const scaleFront = 0.15;
  const scaleSide = 0.075;
  
  const frontWidth = vehicle.width * scaleFront + padding * 2;
  const frontHeight = vehicle.height * scaleFront + padding * 2;
  
  const colors = ['#D97706', '#EF4444', '#3B82F6', '#10B981', '#8B5CF6', '#F59E0B', '#EC4899', '#14B8A6'];
  const diameterColors = {};
  let colorIndex = 0;
  
  const frontView = (
    <div className="flex flex-col items-center">
      <div className="text-[10px] text-neutral-500 font-mono mb-2">–í–∏–¥ —Å–ø–µ—Ä–µ–¥–∏</div>
      <svg width={frontWidth} height={frontHeight} className="border border-neutral-700 rounded">
        <rect
          x={padding}
          y={padding}
          width={vehicle.width * scaleFront}
          height={vehicle.height * scaleFront}
          fill="none"
          stroke="#4B5563"
          strokeWidth="2"
          strokeDasharray="4 2"
        />
        
        {simulator.layers.map((layer, layerIdx) => {
          return layer.pipes.map((pipe, pipeIdx) => {
            if (!diameterColors[pipe.diameter]) {
              diameterColors[pipe.diameter] = colors[colorIndex % colors.length];
              colorIndex++;
            }
            const color = diameterColors[pipe.diameter];
            const radius = (pipe.diameter * scaleFront) / 2;
            
            return Array.from({ length: pipe.count }).map((_, i) => {
              const cx = padding + (pipe.x + pipe.diameter * i + pipe.diameter / 2) * scaleFront;
              const cy = frontHeight - padding - (layer.y + pipe.diameter / 2) * scaleFront;
              
              return (
                <g key={`${layerIdx}-${pipeIdx}-${i}`}>
                  <circle
                    cx={cx}
                    cy={cy}
                    r={Math.max(radius - 1, 2)}
                    fill={color}
                    opacity={0.7}
                    stroke={color}
                    strokeWidth="1.5"
                  />
                  <text
                    x={cx}
                    y={cy + 2}
                    textAnchor="middle"
                    fill="#000"
                    fontSize="8"
                    fontWeight="bold"
                    fontFamily="monospace"
                  >
                    {pipe.diameter}
                  </text>
                </g>
              );
            });
          });
        })}
        
        <text x={padding} y={frontHeight - padding + 12} fill="#888" fontSize="9" fontFamily="monospace">
          {vehicle.width} –º–º
        </text>
        <text x={5} y={padding + 10} fill="#888" fontSize="9" fontFamily="monospace" textAnchor="start">
          {vehicle.height} –º–º
        </text>
      </svg>
    </div>
  );
  
  const sideWidth = vehicle.length * scaleSide + padding * 2;
  const sideHeight = vehicle.height * scaleSide + padding * 2;
  
  const sideView = (
    <div className="flex flex-col items-center">
      <div className="text-[10px] text-neutral-500 font-mono mb-2">–í–∏–¥ —Å–±–æ–∫—É</div>
      <svg width={sideWidth} height={sideHeight} className="border border-neutral-700 rounded">
        <rect
          x={padding}
          y={padding}
          width={vehicle.length * scaleSide}
          height={vehicle.height * scaleSide}
          fill="none"
          stroke="#4B5563"
          strokeWidth="2"
          strokeDasharray="4 2"
        />
        
        {simulator.layers.map((layer, idx) => {
          const y = sideHeight - padding - (layer.y + layer.height) * scaleSide;
          const height = layer.height * scaleSide;
          
          return (
            <g key={idx}>
              <rect
                x={padding}
                y={y}
                width={vehicle.length * scaleSide}
                height={height}
                fill={diameterColors[layer.pipes[0]?.diameter] || '#888'}
                opacity={0.6}
                stroke={diameterColors[layer.pipes[0]?.diameter] || '#666'}
                strokeWidth="1.5"
              />
              <text
                x={padding + (vehicle.length * scaleSide) / 2}
                y={y + height / 2 + 3}
                textAnchor="middle"
                fill="#000"
                fontSize="9"
                fontWeight="bold"
                fontFamily="monospace"
              >
                √ò{layer.pipes[0]?.diameter}
              </text>
            </g>
          );
        })}
        
        <text x={padding} y={sideHeight - padding + 12} fill="#888" fontSize="9" fontFamily="monospace">
          {vehicle.length} –º–º
        </text>
        <text x={5} y={padding + 10} fill="#888" fontSize="9" fontFamily="monospace" textAnchor="start">
          {vehicle.height} –º–º
        </text>
      </svg>
    </div>
  );
  
  return (
    <div className="flex gap-6 mt-4 flex-wrap justify-center">
      {frontView}
      {sideView}
    </div>
  );
}

function ResultsPanel({ result, vehicle }) {
  return (
    <div className="mt-2">
      <div className="flex gap-3 mb-6 flex-wrap">
        <StatCard label="–û–±—â–∏–π –≤–µ—Å" value={formatKg(result.totalWeight)} />
        <StatCard label="–ò–¢–û–ì–û –∞–≤—Ç–æ" value={result.totalVehicles} sub={vehicle.name.toLowerCase()} accent />
      </div>
      
      <div className="text-sm font-semibold text-neutral-500 font-mono uppercase tracking-wide mb-3">–î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ –∞–≤—Ç–æ</div>
      
      <div className="flex flex-col gap-3">
        {result.vehicles.map((v, i) => (
          <div key={i} className="bg-neutral-950 border border-neutral-800 rounded-lg p-5">
            <div className="flex items-baseline gap-3 mb-3">
              <span className="text-lg font-bold text-amber-500 font-mono">{vehicle.name} #{i + 1}</span>
              <span className="text-sm text-neutral-500">{formatKg(v.weight)}</span>
              {v.type === 'mixed' && <span className="text-xs px-2 py-1 bg-green-900 text-green-300 rounded font-mono">–°–ú–ï–®–ê–ù–ù–ê–Ø</span>}
            </div>
            
            <div className="space-y-2 mb-4">
              {v.composition.map((item, j) => (
                <div key={j} className="flex items-center gap-3 text-sm">
                  <span className="text-amber-400 font-mono">√ò{item.diameter}</span>
                  <span className="text-neutral-500">√ó</span>
                  <span className="text-neutral-300 font-mono">{formatMm(item.length)}</span>
                  <span className="text-neutral-500">‚Äî</span>
                  <span className="text-neutral-200 font-semibold">{item.count} —à—Ç</span>
                  <span className="text-neutral-600 text-xs ml-auto">{formatKg(item.count * item.weightPerMeter * (item.length / 1000))}</span>
                </div>
              ))}
            </div>
            
            {v.simulator && <TruckVisualization simulator={v.simulator} vehicle={vehicle} />}
          </div>
        ))}
      </div>
    </div>
  );
}

export default function LogisticsCalculator() {
  const [rows, setRows] = useState([]);
  const [vehicleType, setVehicleType] = useState("truck");
  const [materialId, setMaterialId] = useState("steel");
  const [calcResult, setCalcResult] = useState(null);
  const [calcVehicle, setCalcVehicle] = useState(null);
  const [requestInfo, setRequestInfo] = useState(null);
  const fileInputRef = useRef(null);

  const vehicle = vehicleType === "truck" ? TRUCK : WAGON;
  const material = MATERIALS.find(m => m.id === materialId) || MATERIALS[0];

  const quickTotals = useMemo(() => ({
    weight: rows.reduce((s, r) => s + calcPipeWeight(r), 0),
  }), [rows]);

  function doCalc() {
    const result = calcVehicles(rows, vehicle);
    result._rows = rows;
    setCalcResult(result);
    setCalcVehicle(vehicle);
  }

  function updateRow(id, updated) { setRows(prev => prev.map(r => r.id === id ? { ...updated, id } : r)); }
  function removeRow(id) { setRows(prev => prev.filter(r => r.id !== id)); }
  function addRow() {
    const wpm = calcWeightPerMeter(57, 3.5, material.density);
    setRows(prev => [...prev, { id: generateId(), diameter: 57, thickness: 3.5, length: 12000, count: 1, weightPerMeter: wpm, totalMeters: 12 }]);
  }

  function clearAll() { setRows([]); setCalcResult(null); setRequestInfo(null); }

  function handleMaterialChange(newId) {
    const newMat = MATERIALS.find(m => m.id === newId) || MATERIALS[0];
    setMaterialId(newId);
    setRows(prev => prev.map(r => ({ ...r, weightPerMeter: calcWeightPerMeter(r.diameter, r.thickness, newMat.density) })));
  }

  function parseNumber(str) {
    if (str === null || str === undefined || str === "") return 0;
    const cleaned = String(str).replace(",", ".");
    const num = parseFloat(cleaned);
    return isNaN(num) ? 0 : num;
  }

  function extractDiameter(name) {
    if (!name) return 0;
    const match = name.match(/(\d+(?:[.,]\d+)?)\s*[—Öx–•X√ó]\s*(\d+(?:[.,]\d+)?)/);
    if (match) return parseNumber(match[1]);
    return 0;
  }

  function handleFileUpload(e) {
    const file = e.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const json = JSON.parse(event.target.result);
        
        setRequestInfo({
          requestId: json.requestId || "",
          client: json.client || "",
          requestDate: json.requestDate || ""
        });

        const mat = json.material && MATERIALS.find(m => m.id === json.material);
        if (mat) setMaterialId(mat.id);

        const positions = json.positions || [];
        processPositions(positions, 0);
      } catch (err) {
        alert("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: " + err.message);
      }
    };
    reader.readAsText(file);
    e.target.value = "";
  }

  function processPositions(positions, defaultLength) {
    const newRows = [];
    
    positions.forEach(pos => {
      const diameter = pos.diameter ? parseNumber(pos.diameter) : extractDiameter(pos.name);
      const thickness = parseNumber(pos.thickness);
      let length = parseNumber(pos.length);
      const totalMeters = parseNumber(pos.totalMeters);
      
      if (length === 0) {
        if (totalMeters > 0 && totalMeters < 6) {
          length = Math.round(totalMeters * 1000);
        } else {
          length = 12000;
        }
      }
      
      if (diameter <= 0 || thickness <= 0 || length <= 0) return;

      let count = pos.count ? parseNumber(pos.count) : 0;
      
      if (count === 0 && totalMeters > 0 && length > 0) {
        if (totalMeters < 6 && length === Math.round(totalMeters * 1000)) {
          count = 1;
        } else {
          count = Math.ceil(totalMeters / (length / 1000));
        }
      }
      
      if (count === 0) count = 1;

      let weightPerMeter = parseNumber(pos.weightPerMeter);
      if (weightPerMeter <= 0) {
        weightPerMeter = calcWeightPerMeter(diameter, thickness, material.density);
      }

      newRows.push({
        id: generateId(),
        diameter,
        thickness,
        length,
        count,
        weightPerMeter,
        totalMeters
      });
    });

    setRows(prev => [...prev, ...newRows]);
    setCalcResult(null);
  }

  const isChanged = calcResult === null || calcVehicle !== vehicle || rows !== calcResult._rows;

  return (
    <div className="min-h-screen bg-neutral-950 text-neutral-200 pb-10">
      <div className="bg-gradient-to-b from-neutral-900 to-neutral-950 border-b border-neutral-800 px-8 pt-6 pb-5 mb-6">
        <div className="flex items-center gap-3 mb-1.5">
          <div className="w-1.5 h-7 bg-amber-600 rounded-sm" />
          <h1 className="m-0 text-xl font-bold tracking-tight font-mono">–õ–û–ì–ò–°–¢–ò–ö–ê –¢–†–£–ë</h1>
        </div>
        <p className="m-0 text-xs text-neutral-600 pl-4.5 font-mono">
          –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏ ‚Ä¢ 2D –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è ‚Ä¢ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è 1–°
        </p>
      </div>

      <div className="px-8 max-w-[1100px] mx-auto">
        {requestInfo && (
          <div className="bg-neutral-900 border border-neutral-700 rounded-md p-3 mb-4 text-xs font-mono">
            <div className="flex gap-6 flex-wrap">
              <span className="text-neutral-500">–ó–∞—è–≤–∫–∞: <strong className="text-neutral-200">{requestInfo.requestId}</strong></span>
              {requestInfo.client && <span className="text-neutral-500">–ö–ª–∏–µ–Ω—Ç: <strong className="text-neutral-200">{requestInfo.client}</strong></span>}
              {requestInfo.requestDate && <span className="text-neutral-500">–î–∞—Ç–∞: <strong className="text-neutral-200">{requestInfo.requestDate}</strong></span>}
            </div>
          </div>
        )}

        <div className="flex gap-2 mb-3">
          {[{ key: "truck", label: "–§—É—Ä–∞ (22 —Ç)", sub: "13.6 √ó 2.44 √ó 2.58 –º" }, { key: "wagon", label: "–ü–æ–ª—É–≤–∞–≥–æ–Ω (63 —Ç)", sub: "12.68 √ó 2.83 √ó 2.17 –º" }].map(v => (
            <button key={v.key} onClick={() => setVehicleType(v.key)} className={`flex-1 rounded-md px-4 py-3 cursor-pointer text-left transition-all ${vehicleType === v.key ? 'bg-stone-900 border border-amber-600' : 'bg-neutral-950 border border-neutral-800'}`}>
              <div className={`text-sm font-semibold font-mono ${vehicleType === v.key ? 'text-amber-500' : 'text-neutral-500'}`}>{v.label}</div>
              <div className="text-[11px] text-neutral-600 mt-0.5">{v.sub}</div>
            </button>
          ))}
        </div>

        <div className="flex items-center gap-3 mb-5">
          <span className="text-xs text-neutral-500 font-mono">–ú–∞—Ç–µ—Ä–∏–∞–ª:</span>
          <select value={materialId} onChange={e => handleMaterialChange(e.target.value)} className="bg-neutral-950 border border-neutral-700 rounded px-3 py-2 text-sm text-neutral-200 font-mono cursor-pointer outline-none">
            {MATERIALS.map(m => <option key={m.id} value={m.id}>{m.name} ({m.density} –∫–≥/–º¬≥)</option>)}
          </select>
          <span className="text-[11px] text-neutral-600 font-mono">œÅ = {material.density} –∫–≥/–º¬≥</span>
        </div>

        <div className="bg-neutral-950 border border-neutral-800 rounded-lg overflow-hidden mb-4">
          <div className="px-4 py-3 border-b border-neutral-900 flex justify-between items-center">
            <span className="text-sm font-semibold text-neutral-500 font-mono uppercase tracking-wide">–ü–æ–∑–∏—Ü–∏–∏ —Ç—Ä—É–±</span>
            <div className="flex gap-2">
              <input
                ref={fileInputRef}
                type="file"
                accept=".json,.txt"
                onChange={handleFileUpload}
                className="hidden"
              />
              <button 
                onClick={() => fileInputRef.current?.click()}
                className="bg-transparent border border-neutral-700 rounded px-3 py-1.5 text-[11px] text-neutral-400 cursor-pointer font-mono hover:border-amber-600 hover:text-amber-500 transition-colors"
              >
                üìÅ –ó–ê–ì–†–£–ó–ò–¢–¨ –§–ê–ô–õ
              </button>
              {rows.length > 0 && <button onClick={clearAll} className="bg-transparent border border-neutral-700 rounded px-3 py-1.5 text-[11px] text-neutral-600 cursor-pointer font-mono hover:border-neutral-600">–û–ß–ò–°–¢–ò–¢–¨</button>}
              <button onClick={addRow} className="bg-amber-600 text-black border-0 rounded px-3.5 py-1.5 text-xs font-bold cursor-pointer font-mono hover:bg-amber-500">+ –î–û–ë–ê–í–ò–¢–¨</button>
            </div>
          </div>
          <div className="overflow-x-auto">
            <table className="w-full border-collapse">
              <tbody>{rows.map((row, i) => <InputRow key={row.id} row={row} index={i} onChange={u => updateRow(row.id, u)} onRemove={() => removeRow(row.id)} density={material.density} />)}</tbody>
            </table>
          </div>
          {rows.length === 0 && <div className="py-8 text-center text-neutral-600 text-sm font-mono">–î–æ–±–∞–≤—å—Ç–µ –ø–æ–∑–∏—Ü–∏–∏ –≤—Ä—É—á–Ω—É—é –∏–ª–∏ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑ 1–°</div>}
          {rows.length > 0 && (
            <div className="px-4 py-2.5 border-t border-neutral-700 flex justify-between items-center text-xs font-mono">
              <div className="flex gap-6">
                <span className="text-neutral-500">–í–µ—Å: <strong className="text-amber-600">{formatKg(quickTotals.weight)}</strong></span>
                <span className="text-neutral-500">–ü–æ–∑–∏—Ü–∏–π: <strong className="text-neutral-400">{rows.length}</strong></span>
              </div>
            </div>
          )}
        </div>

        {rows.length > 0 && (
          <button onClick={doCalc} className={`w-full py-4 text-base font-bold font-mono tracking-wide rounded-lg cursor-pointer mb-6 transition-all ${isChanged ? 'bg-gradient-to-br from-amber-600 to-amber-700 text-black border-0 shadow-lg shadow-amber-600/30' : 'bg-stone-900 text-amber-600 border border-amber-600'}`}>
            {isChanged ? "‚ñ∂ –†–ê–°–°–ß–ò–¢–ê–¢–¨ –° –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ï–ô" : "‚úì –†–ê–°–ß–Å–¢ –ê–ö–¢–£–ê–õ–ï–ù"}
          </button>
        )}

        {calcResult && calcResult.vehicles.length > 0 && <ResultsPanel result={calcResult} vehicle={calcVehicle} />}
      </div>
    </div>
  );
}
